<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <title>Places Searchbox</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #map {
        height: 55%;
      }
      .controls {
        margin-top: 10px;
        border: 1px solid transparent;
        border-radius: 2px 0 0 2px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        height: 32px;
        outline: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      #pac-input {
        background-color: #fff;
        font-family: Roboto;
        font-size: 15px;
        font-weight: 300;
        margin-left: 12px;
        padding: 0 11px 0 13px;
        text-overflow: ellipsis;
        width: 300px;
      }

      #pac-input:focus {
        border-color: #4d90fe;
      }

      .pac-container {
        font-family: Roboto;
      }

      #type-selector {
        color: #fff;
        background-color: #4d90fe;
        padding: 5px 11px 0px 11px;
      }

      #type-selector label {
        font-family: Roboto;
        font-size: 13px;
        font-weight: 300;
      }
      #target {
        width: 345px;
      }
    </style>
  </head>
  <body>
    <div>
        <p>Search for an 'establishment' using the input box on the map,
        and anything matching will be shown as an icon the map. Clicking
        on an icon will populate the address form. The form is then
        converted to JSON (to be submitted to an API, etc).
        </p>
        <span>JSON:</span>
        <pre style="background-color: #DDD;" id="json">
            

        </pre>
        <form id="theForm" onsubmit="return false;">
   
    <!-- <div id="autocompleteWrapper">
        <label for="autocomplete"><b>Required:</b>&nbsp;Search for Customer Address </label>
        <input type="text" id="autocomplete" name="user_address_input" style="width: 100%">
        <p style="font-size: small">Note: in the future, Customer or Business Name may be able to auto-fill everything except BULK/EXCHANGE, and Parent Company</p>
    </div> -->
    </tr>
    </table>
    <div id="results" style="">
        <!-- ReSULTS TABLE -->
        <table>
            <tr>
                <td><!-- road -->
                <span>
                    <label for="street_number">Street Address</label>
                </span>
                </td><td>
                <span>
                    <input disabled="" type="text" class="numberField" id="street_number" name="street_number"/>
                </span>
            <!-- --></td><td colspan="2">
                <span>
                    <input disabled="" type="text" class="largeField" id="route" name="route"/>
                </span>
            </td>
        </tr>
        <tr>
        <tr><!-- city, state, zip -->
        <td colspan="2">
            <span >
                <label for="locality">City</label>
                <input disabled="" type="text" class="medField" id="locality" name="locality">
            </span>
        </td><td>
            <span>
                <label for="administrative_area_level_1">State</label>
                <input disabled="" type="text" class="smallField" id="administrative_area_level_1" name="administrative_area_level_1">
            </span>
        </td><td>
            <span>
                <label for="postal_code">Zip Code</label>
                <input disabled="" type="text" class="medField" id="postal_code" name="postal_code">
            </span>
        </td>
        </tr><tr>
        <td colspan="2">
        <!-- county; lat, lng from geometry-->
            <span>
               <label for="administrative_area_level_2">County</label>
                <input disabled="" type="text" class="medField" id="administrative_area_level_2" name="administrative_area_level_2">
            </span>
        </td><td>
            <span>
                <label for="location_lat">Lat</label>
                <input disabled="" type="text" class="smallField" id="location_lat" name="location_lat">
            </span>
        </td><td>
            <span>
                <label for="location_lng">Lng</label>
                <input disabled="" type="text" class="smallField" id="location_lng" name="location_lng">
            </span>
        </td>
        </tr>
    </table>
         </div><!-- end results div -->

    </form>
    </div>
      <input id="pac-input" class="controls" type="text" placeholder="Search Box">
    <div id="map"></div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script>
      // This example adds a search box to a map, using the Google Place Autocomplete
      // feature. People can enter geographical searches. The search box will return a
      // pick list containing a mix of places and predicted search terms.

      // This example requires the Places library. Include the libraries=places
      // parameter when you first load the API. For example:
      // <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places">

      function initAutocomplete() {
        var map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: -33.8688, lng: 151.2195},
          zoom: 13,
          mapTypeId: 'roadmap'
          , types: 'establishment'
        });

        // Create the search box and link it to the UI element.
        var input = document.getElementById('pac-input');
        var searchBox = new google.maps.places.SearchBox(input);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
        // PlacesService for place details
        var service = new google.maps.places.PlacesService(map);

        // Bias the SearchBox results towards current map's viewport.
        map.addListener('bounds_changed', function() {
          searchBox.setBounds(map.getBounds());
        });

        var markers = [];
        // handler user select
        // Listen for the event fired when the user selects a prediction and retrieve
        // more details for that place.
        searchBox.addListener('places_changed', function() {
          var places = searchBox.getPlaces();

          if (places.length == 0) {
            return;
          } else {
            console.log("Processing " + places.length + " # of places");
          }
          // Only one result? Great, populate now
          if (places.length == 1) {
            // TODO: Could be an ATM, need consistent filtering
            // use fetch, gets more info only if needed
            fetchPlaceAddress(places[0], service, fillInAddress);
          }
          
          // Clear out the old markers.
          markers.forEach(function(marker) {
            marker.setMap(null);
          });
          markers = [];

          // update the bounds as results come in
          // TODO: Don't do this when we ignore results, otherwise
          // our old bounds will be reset when we should instead warn of no
          // results
          var bounds = new google.maps.LatLngBounds();
          
          // For each place, get the icon, name and location.
          places.forEach(function(place) {
            if (!place.geometry) {
                var n;
                if (!place.name) {
                    n = "(Un-named place)";
                }
                else {
                    n = place.name;
                }
              console.log(n + " contains no geometry");
              return;
            }
            // TODO: Filter out un-used places
            var x = -1;
            // ignore a certain type of result
            //if (place.types) {
            //    var type = 'atm';
            //    x = place.types.indexOf(type)
            //    console.log(type + ' place' + place.name + ' found at index ' + x)
            //}
            
            if (true){ //TODO: filering if(x != 0 ){
                
                var icon = {
                  url: place.icon,
                  size: new google.maps.Size(34, 34),
                  origin: new google.maps.Point(0, 0),
                  anchor: new google.maps.Point(17, 34),
                  scaledSize: new google.maps.Size(25, 25)
                };
    
                // Create a marker for each place.
                var marker = new google.maps.Marker({
                  map: map,
                  icon: icon,
                  title: place.name,
                  position: place.geometry.location
                });
                markers.push(marker);
                var p = place;
                marker.addListener('click', clickHandlerForPlace(p, service, fillInAddress));
                
                // calculate new view bounds
                if (place.geometry.viewport) {
                  // Only geocodes have viewport.
                  bounds.union(place.geometry.viewport);
                } else {
                  bounds.extend(place.geometry.location);
                }
            } // end if for filtering
          });
          
          // set view bounds
          map.fitBounds(bounds);
        }); // end handler
        
        // don't show icons unless we place them
        // but show roads and administrative labels
        var remove_poi = [
         {
           "featureType": "all",
           "elementType": "labels",
           "stylers": [
             { "visibility": "off" }
           ]
         },
          {
           "featureType": "road",
           "elementType": "labels",
           "stylers": [
             { "visibility": "on" }
           ]
         },
          {
           "featureType": "administrative",
           "elementType": "labels",
           "stylers": [
             { "visibility": "on" }
           ]
         }
       ]
       map.setOptions({styles: remove_poi})
      }

      /*
       * Take place details and fill in the form
       * elements with the values
       */
      function fillInAddress(place,status) {
        // These correspond to element ids in the form
        var componentForm = {
            street_number: 'short_name',
            route: 'long_name',
            locality: 'long_name',
            administrative_area_level_1: 'short_name',
            administrative_area_level_2: 'short_name',
            // country: 'long_name',
            postal_code: 'short_name'
          };
        // Get the place details from the autocomplete object.
        // var place = autocomplete.getPlace();
        for (var component in componentForm) {
          document.getElementById(component).value = '';
          document.getElementById(component).disabled = false;
        }

        // Get each component of the address from the place details
        // and fill the corresponding field on the form.
        for (var i = 0; i < place.address_components.length; i++) {
          
          // LOG  
          console.log(place.address_components[i].types[0] + " = "
                        + place.address_components[i]["short_name"]);
          
          var addressType = place.address_components[i].types[0];
          if (componentForm[addressType]) {
            var val = place.address_components[i][componentForm[addressType]];
            document.getElementById(addressType).value = val;
          }
        }
        var lat, lng;
        lat = place.geometry.location.lat();
        lng = place.geometry.location.lng();

        document.getElementById("location_lat").value = lat;
        document.getElementById("location_lat").disabled = true;
        document.getElementById("location_lng").value = lng;
        document.getElementById("location_lng").disabled = true;
        var j = $("#theForm").serialize()
        $("#json").text(j);
        console.log(j);
        
    }
      
      
    /*
     * Fetch place details and execute callback
     */
    function  fetchPlaceAddress(p, service, callback){
        // DEBUG: checking out what types we get back..
        var s = p.name;
        for (var i in p.types) {
         s += ": " + p.types[i];
        }
        console.log(s);
        if (!p.address_components) {
          console.log("Fetching details...");
          service.getDetails({
            placeId: p.place_id
          }, function(place, status) {
              if (status === google.maps.places.PlacesServiceStatus.OK) {
                  callback(place)
              } else {
                // TODO: Warn user no address available for that option
                var place_name;
                if (!place.name) {
                    place_name = "(undefined)";
                } else {
                    place_name = place.name;
                }
                console.log("Place details not found!" + place_name)
              }
          });
        } else {
            // we already have the details we want, so go ahead
            callback(p);
       }
    }
    /*
     * Returns a click event handler for use with
     * fetching place details
     */
    function clickHandlerForPlace(p, service, callback){
        return function(event) {
            fetchPlaceAddress(p, service, callback);      
        }
    }
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBWNNCsmSfb0gpZv3IuK1c91cctc2y6FYY&libraries=places&amp;callback=initAutocomplete"
         async defer></script>
  </body>
</html>